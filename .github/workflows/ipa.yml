name: Build IPA
on: [push, pull_request, workflow_dispatch]

jobs:
  iOS:
    runs-on: macos-15
    env:
      RUSTC_WRAPPER: sccache
      SCCACHE_CACHE_SIZE: 5G
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
      - uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable
      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-ios
      - uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            src-tauri
          cache-all-crates: true
          cache-on-failure: true
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest
      - name: Cache Bun and node_modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            ~/.cache/bun
            **/node_modules
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: |
            ${{ runner.os }}-bun-
      - name: Install sccache
        run: brew install sccache
      - name: Cache sccache
        uses: actions/cache@v4
        with:
          path: ~/.cache/sccache
          key: ${{ runner.os }}-sccache-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-sccache-

      # Build frontend with bun so tauri-build can embed assets
      - name: Install frontend deps
        run: bun install
      - name: Build frontend
        run: bun run build

      - name: Detect dist dir for tauri assets
        shell: bash
        run: |
          set -eux
          # Pick first existing candidate directory
          candidates=(dist build public/build build/dist apps/web/dist packages/*/dist)
          for d in "${candidates[@]}"; do
            for p in $d; do
              if [ -d "$p" ]; then
                echo "TAURI_DIST_DIR=$(pwd)/$p" >> "$GITHUB_ENV"
                echo "Using TAURI_DIST_DIR=$p"
                exit 0
              fi
            done
          done
          # Fallback to ./dist even if it doesn't exist (tauri may embed nothing)
          echo "TAURI_DIST_DIR=$(pwd)/dist" >> "$GITHUB_ENV"
          echo "No dist dir detected; set TAURI_DIST_DIR=./dist"

      # Create a prod tauri config and point distDir to a stable location so assets are embedded.
      - name: Prepare prod Tauri config and assets
        shell: bash
        env:
          TAURI_DIST_DIR: ${{ env.TAURI_DIST_DIR }}
        run: |
          set -eux
          ROOT="$GITHUB_WORKSPACE"
          SRC_TAURI="$ROOT/src-tauri"
          PROD_DIST="$ROOT/.ci-dist"
          mkdir -p "$PROD_DIST"
          # Sync built frontend into a stable path
          if [ -d "$TAURI_DIST_DIR" ]; then
            rsync -a --delete "$TAURI_DIST_DIR"/ "$PROD_DIST"/ || cp -R "$TAURI_DIST_DIR"/. "$PROD_DIST"/
          fi

          python3 - << 'PY'
          import json, os
          from pathlib import Path

          root = Path(os.environ["GITHUB_WORKSPACE"])
          src_tauri = root / "src-tauri"
          prod_dist_rel = "../.ci-dist"  # relative to src-tauri
          cfg_in = src_tauri / "tauri.conf.json"
          cfg = {}
          if cfg_in.exists():
            with open(cfg_in, "r", encoding="utf-8") as f:
              cfg = json.load(f)

          # v1/v2 compatible patching:
          build = cfg.setdefault("build", {})
          # Remove dev server pointers
          for k in ("devPath", "devUrl"):
            build.pop(k, None)
          # Only set frontendDist (distDir is invalid for current tauri-build)
          build["frontendDist"] = prod_dist_rel

          app = cfg.setdefault("app", {})
          wins = app.setdefault("windows", [])
          if isinstance(wins, list) and wins:
            for w in wins:
              if isinstance(w, dict):
                w["url"] = "tauri://localhost"
          else:
            app["windows"] = [{"url": "tauri://localhost"}]

          out = Path(os.environ["RUNNER_TEMP"]) / "tauri.conf.prod.json"
          with open(out, "w", encoding="utf-8") as f:
            json.dump(cfg, f, indent=2)

          # Export TAURI_CONFIG as minified single-line JSON to GITHUB_ENV
          env_path = Path(os.environ["GITHUB_ENV"])
          with open(env_path, "a", encoding="utf-8") as f:
            f.write("TAURI_CONFIG=" + json.dumps(cfg, separators=(",", ":")) + "\n")
          PY

          # Gather app metadata (name/version/bundle id) from Cargo.toml and tauri.conf.json
      - name: Extract app metadata
        shell: bash
        run: |
          python3 - << 'PY' >> "$GITHUB_ENV"
          import json
          from pathlib import Path
          import tomllib

          root = Path.cwd()
          cargo = root / "src-tauri" / "Cargo.toml"
          name = "app"
          version = "0.1.0"
          if cargo.exists():
            data = tomllib.load(open(cargo, "rb"))
            pkg = data.get("package", {})
            name = pkg.get("name", name)
            version = pkg.get("version", version)

          bundle_id = f"com.example.{name}"
          display_name = name

          tc = root / "src-tauri" / "tauri.conf.json"
          if tc.exists():
            with open(tc, "r", encoding="utf-8") as f:
              j = json.load(f)
            # Try both v2 and legacy shapes
            appcfg = j.get("app") or j.get("tauri", {}).get("app", {}) or {}
            prod_name = appcfg.get("productName")
            if isinstance(prod_name, str) and prod_name.strip():
              display_name = prod_name.strip()
            bundle = appcfg.get("bundle") or {}
            bid = bundle.get("identifier")
            if isinstance(bid, str) and bid.strip():
              bundle_id = bid.strip()

          # Keep hyphens; matches Cargo's executable filename
          bin_name = name
          bin_name_alt = name.replace("-", "_")

          print(f"APP_NAME={display_name}")
          print(f"BINARY_NAME={bin_name}")
          print(f"BINARY_NAME_ALT={bin_name_alt}")
          print(f"APP_VERSION={version}")
          print(f"BUNDLE_ID={bundle_id}")
          PY

      # Build the Rust iOS binary (unsigned), ensuring assets are embedded via TAURI_DIST_DIR
      - name: Build Rust (aarch64-apple-ios)
        env:
          TAURI_CONFIG: ${{ env.TAURI_CONFIG }}
          TAURI_SKIP_DEVSERVER: "true"
          TAURI_DEV: "false"
        run: |
          cd src-tauri
          cargo build --release --target aarch64-apple-ios

      # Manually assemble the .app bundle and create an unsigned .ipa
      - name: Bundle .app and create unsigned .ipa
        shell: bash
        env:
          TAURI_DIST_DIR: ${{ env.TAURI_DIST_DIR }}
          APP_NAME: ${{ env.APP_NAME }}
          BINARY_NAME: ${{ env.BINARY_NAME }}
          BINARY_NAME_ALT: ${{ env.BINARY_NAME_ALT }}
          APP_VERSION: ${{ env.APP_VERSION }}
          BUNDLE_ID: ${{ env.BUNDLE_ID }}
        run: |
          set -eux
          PAYLOAD_DIR="$RUNNER_TEMP/Payload"
          APP_DIR="$PAYLOAD_DIR/${APP_NAME}.app"
          mkdir -p "$APP_DIR"

          TARGET_DIR="src-tauri/target/aarch64-apple-ios/release"
          CANDIDATES=(
            "$TARGET_DIR/${BINARY_NAME}"
            "$TARGET_DIR/${BINARY_NAME_ALT:-${BINARY_NAME//-/_}}"
          )
          BIN_PATH=""
          for c in "${CANDIDATES[@]}"; do
            if [ -f "$c" ]; then
              BIN_PATH="$c"
              break
            fi
          done
          if [ -z "$BIN_PATH" ]; then
            echo "Binary not found. Looked for:"
            printf '  - %s\n' "${CANDIDATES[@]}"
            ls -la "$TARGET_DIR" || true
            exit 1
          fi

          cp "$BIN_PATH" "$APP_DIR/$APP_NAME"
          chmod +x "$APP_DIR/$APP_NAME"

          # Optional: keep fallback assets in bundle (not required if embedded)
          if [ -d "$TAURI_DIST_DIR" ]; then
            mkdir -p "$APP_DIR/tauri"
            rsync -a "$TAURI_DIST_DIR"/ "$APP_DIR/tauri"/ || cp -R "$TAURI_DIST_DIR"/. "$APP_DIR/tauri"/
          fi

          cat > "$APP_DIR/Info.plist" <<PLIST
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0"><dict>
            <key>CFBundleDevelopmentRegion</key><string>en</string>
            <key>CFBundleExecutable</key><string>${APP_NAME}</string>
            <key>CFBundleIdentifier</key><string>${BUNDLE_ID}</string>
            <key>CFBundleInfoDictionaryVersion</key><string>6.0</string>
            <key>CFBundleName</key><string>${APP_NAME}</string>
            <key>CFBundleDisplayName</key><string>${APP_NAME}</string>
            <key>CFBundlePackageType</key><string>APPL</string>
            <key>CFBundleShortVersionString</key><string>${APP_VERSION}</string>
            <key>CFBundleVersion</key><string>${APP_VERSION}</string>
            <key>LSRequiresIPhoneOS</key><true/>
            <key>UIDeviceFamily</key><array><integer>1</integer><integer>2</integer></array>
            <key>UISupportedInterfaceOrientations</key>
            <array><string>UIInterfaceOrientationPortrait</string></array>
            <key>UIRequiredDeviceCapabilities</key><array><string>arm64</string></array>
            <key>UILaunchScreen</key><dict/>
            <!-- Allow http if any plugin tries to use it (not needed for tauri://) -->
            <key>NSAppTransportSecurity</key><dict><key>NSAllowsArbitraryLoads</key><true/></dict>
          </dict></plist>
          PLIST

          IPA_PATH="$RUNNER_TEMP/${APP_NAME}-${APP_VERSION}-unsigned.ipa"
          (cd "$RUNNER_TEMP" && /usr/bin/zip -qry "$IPA_PATH" Payload)
          echo "IPA_PATH=$IPA_PATH" >> "$GITHUB_ENV"

      - name: Upload unsigned IPA
        uses: actions/upload-artifact@v4
        with:
          name: ios-ipa-unsigned
          path: ${{ env.IPA_PATH }}
          if-no-files-found: error
